# Infinite sequences

**Concept:**

- Generators, by their nature of pausing and resuming execution, can be used to create functions that generate values indefinitely. This is because they are not bound to a finite set of instructions like regular functions.
- The key lies in utilizing the `yield` keyword strategically within the generator function to control the flow and prevent the function from reaching a complete `return` statement.

**Implementation:**

Here's a basic example of an infinite sequence generator for natural numbers:

```javascript
function* naturalNumbers() {
  let i = 1;
  while (true) {
    yield i;
    i++;
  }
}
```

Explanation:

- The `naturalNumbers` function is a generator (`function*`).
- It uses a `while(true)` loop to create an infinite loop.
- Inside the loop, it `yield`s the current value of `i` (which starts at 1).
- After yielding, it increments `i` to prepare for the next iteration.

**Using the Infinite Sequence:**

However, you cannot directly iterate through an infinite sequence forever in practice. Here are a couple of approaches to use and control the infinite sequence generated by the function:

1. **`for...of` loop with a condition:**

```javascript
const numbers = naturalNumbers();

for (const num of numbers) {
  if (num > 10) break; // Stop after 10 numbers
  console.log(num);
}
```

In this approach:

- We call `naturalNumbers()` to get the generator object.
- The `for...of` loop iterates over the generator object (`numbers`).
- We include a `break` statement inside the loop to terminate the iteration after a specific condition (here, after 10 numbers).

2. **Manual Iteration with `next()`:**

```javascript
const numbers = naturalNumbers();

let result = numbers.next();
while (!result.done) {
  console.log(result.value);
  result = numbers.next();
}
```

Here:

- We get the generator object and use `next()` to get the first value.
- We loop while `result.done` is `false` (indicating there are more values).
- Inside the loop, we log the current value (`result.value`) and call `next()` again to move to the next iteration.

**Important Considerations:**

- Infinite sequences can potentially consume memory if not used carefully. It's crucial to have a mechanism to stop iterating or handle memory usage.
- Be mindful of infinite loops that might block your program's execution.

By understanding these concepts, you can leverage generators to create infinite sequences for various use cases like:

- Implementing algorithms that require processing an unknown number of elements.
- Generating random data streams for testing purposes.
- Creating lazy evaluation mechanisms where values are generated only when needed.
